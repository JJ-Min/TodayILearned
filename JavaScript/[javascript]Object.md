# Object And Data Type in JavaScript
##### 자바스크립트의 객체와 데이터 타입에 대해 공부한 내용을 정리한 글입니다.
---

## 1. Primitive Type VS Reference Type
 `자바스크립트의 데이터 타입은 원시형과 참조형으로 구분함`

### Primitive Type(원시형)

- 변수에 할당 될 때 메모리 상에 고장된 크기로 저장됨
- 해당 변수가 원시데이터 값을 보관
- 원시 값을 복사 및 전달 할 때는 값 자체를 복사 및 전달 하기 때문에 원본의 값이 바뀌어도 사본의 값이 함께 바뀌는 것은 아님
~~~js
let a=3;
let b=a;
a=4;
b==4; //false b에는 a 의 값인  3이 복사 되었음
~~~
- `값 자체를 전달`하기 때문에 함수안에서 변수의 값이 바뀌어도 함수 외부에서는 바뀌지 않은 상태로 남아있음.
~~~js
 function f(a){
   a=3;
 }
 let a=5;
 f(a);
 console.log(a) // 5
 // a가 아니라 5가 f의 매개변수로 들어가는거임  
 //즉, 함수의 매개변수 a 와 밑에 있는 변수 a는 이름만 같을뿐 아예 다른 개념임
~~~
- 변수에 새 값이 할당 될 때 변수에 할당된 메모리에 저장된 값을 변경(Access by value)


### Reference Type(참조형)
- 데이터(객체)의 크기가 가변적임
- 객체를 복사 및 전달 할 때는 객체가 아니라 그 `객체를 가리키고 있다는 사실(참조하고 있음)`을 복사및 전달함
~~~js
let o ={a:1};
let p=o; // p는 o를 가리킴
o.a=2;
console.log(p) //{a:2}
~~~
- 참조를 전달 하고 있기 때문에 함수안에서 객체를 변경하면 함수 외부에서도 바뀜
- 객체를 가리키는 변수는 그 객체를 가리키고 있을 뿐, 객체 자체는 아님 (변수 != 객체 )
~~~js
let q={a:1}; // q는 {a:1}이라는 객체를 가리킴
q==={a:1}; //false
~~~
- 변수의 값에 저장된 힙 메모리의 주소값 저장
  - 참조 타입은 변수의 값이 저장되어있는 메모리의 주소를 가지고 있고,자바스크립트 엔진이 변수가 가지고 있는 메모리 주소를 이용해 변수 값에 접근 (Access By Reference)
- **주의**
~~~js
let o={a:1};
let p=o;
p===o; //true
o={a:2}; // 객체를 수정한 것이 아니라 완전히 다른 객체를 가리키는 것임
p===0;//false

let k={a:5};
let s=k;
k.a=7;
console.log(s.a);// 7
k===a ; // true
~~~
---
## Object (객체)

### 1.Object(객체)란?
- 원시형은 단 하나의 값만 나타낼 수 있고 불변이지만, 이와 달리 객체는 여러가지 값이나 복잡한 값을 나타낼 수 있으며 변할 수 있음
- 객체의 본질은 콘테이너
  - 콘테이너의 내용물이 바뀐다고 컨테이너가 바뀌는것 아님
  - 객체 또한 안의 내용이 바뀐다 한들 같은 객체인것임
- {중괄호} 를 사용하는 리터럴 문법
  - 객체의 시작과 끝을 구분
  ~~~js
  const obj={}; // 빈 객체 , 변수 obj는 빈 객체를 가리킴  
  ~~~
- 객체의 콘텐츠는 프로퍼티(Property) 혹은 멤버(Member)라고 부름
  - 프로퍼티는 이름(key)와 값(value)으로 구성
  ~~~js
  obj.color="red" // key=color ,value=red
  ~~~
  - key는 문자열 혹은 심볼만 value 는 어떤 값이던 다 괜찮
  - 프로퍼티의 이름에 유효한 식별자를 써야 멤버 접근 연산자(점 연산자) 사용 가능
  - 유효한 식별자가 아니라면 계산된 멤버 접근 연산자([대괄호]) 사용 (유효한 식별자도 사용 가능)
  ~~~js
  obj.color ="red" // 점 연산자
  obj["I am Ahkong"]=8; // []
  obj["color"]="Yellow";

  const SIZE=Symbol();
  obj.[SIZE]=8; //SIZE 는 심볼임
  obj.SIZE=0; // SIZE는 문자열임 , 점연산자는 문자열 프로퍼티에 대해 동작함
  obj.SIZE==obj.["SIZE"]; //true
  obj.SIZE==obj.[SIZE];//false
  ~~~
- 계속 변수 obj에 저장된 객체를 수정했지만 obj는 항상 같은 객체를 가리킴
  - 만일 obj에 저장된 값이 원시값이였다면 수정 할 때마다 다른 값ㅇ르 가리킴
  - obj는 계속 같은 객체를 가리키고 있고 바뀐것은 그 객체의 Property임

### 2.객체 생성 방법

- 객체 리터럴 문법에서는 객체를 만드는 동시에 프로퍼티를 만들 수 있음
- 중괄호 안에서 각 프로퍼티를 쉼표로 구분하고, 프로퍼티의 이름과 값은 콜론(:)을 구분함

~~~js
const me ={
  name:'Ahkong',
  major:'computer engineering',
} ;

const me2={name:'Ahkong',major:'computer engineering'}
// me!=me2 (같은 프로퍼티를 가졌다 한 들 둘은 전혀 다른 객체임)
const me3={
  name:'Ahkong',
  major:'computer engineering',
  address:{
    county:'South Korea',
    city:'Jeonju'
  }, // 프로퍼티의 값도 객체가 될 수 있음
};

me3.speak=function(){return right developer,right place;};
// 객체에 함수도 담을 수 있음
me3.speak(); //()를 붙혀서 함수 실행  
delete me3.speak //delete를 이용하여 me3의 프로퍼티 제거 가능
~~~


#### 참고

 Learning JavaScript/한빛 미디어
----
#### 마치며

객체가 다 거기서 거기지 하는 마음에 우습게 생각했던 지난 날의 내자신에게 욕한바가지 부어주고 싶었다. 원래는 클로저를 공부하려 했는데 클로저를 공부하다 보니 함수에서 막히고 그래서 함수를 공부하려고 하니 객체에 대한 개념이 제대로 잡혀있지 않아 여기까지 돌아돌아 왔다.....걍 첨부터 객체 공부 했으면 훨씬 수ㅇ월 했을텐데....앞으로는 이런 기본적인 개념을 무시하지 말고 꼼꼼하게 공부해야겠다. 그럼 이제 객체 좀 알겠으니까 다시 함수를 해야겠다 클로저 후하후하 기다려~~~~~~~~~~~~~~~~~~~~~~
