# 자바스크립트 : 프로토타입 기반 언어


- 자바스크립트에는 클래스라는 개념이 없음 -> 상속x
- 대신 ProtoType이 존재
   - 프로토타입을 이용하여 상속을 흉내냄
   - 그래서 프로토타입기반 언어라고 하는 것임
   - 함수와 new 연산자를 통해 클래스를 흉내 낼 순 있음
     - 이렇게 클래스를 흉내 내었을때 문제점?
         kim과 lee는 눈과 코를 공통적으로 갖고 있어서 메모리가 4개가 할당이 됨으로써 메모리 낭비가 발생함
     ~~~js
     function Person(){
       this.eyes=2;
       this.nose=1;
     }

     var kim = new Person();
     var lee = new Person();
     ~~~

  - 위의 문제를 해결하고자 필요한 것이 바로 ProtoType임
     - person.protoype 의 빈 object가 어딘가에 존재하고 Person함수로 인해 생성된 객체들은 어딘가에 존재하는 object에 들어있는 값을 모두 가져다가 쓸 수 있음
     ~~~js
     function Person(){}
     Person.protoype.eyes=2;
     Person.protoype.nose=1;
     var kim = new Person();
     ~~~
~~최근 ECMA6 표준문법에는 Class가 추가 됨 그렇다고 객체지향으로 변한 것은 아님~~
## ProtoType Object + ProtoType Link = ProtoType

#### ProtoType Object

- 객체는 언제나 함수로 생성이 됨
~~~ js
function Person(){}
var personobj=new Person(); // 함수로 객체 생성
~~~
- 함수를 정의 할 때 다음과 같은 일이 일어남 (중요)
   1. 해당 함수에 생성자 (Constructor) 자격 부여
      - new 연산자를 통해 객체를 만들어 낼 수 있게 됨 ===> 함수만 new 키워드 사용 가능한 이유임
  2. 해당 함수의 Prototype object 생성 및 연결
      - 생성된 함수는 Prototype 속성을 이용해 Prototype Object에 접근 가능
      - Prototype Object는 걍 일반적인 객체이기 때문에 속성을 추가 하거나 삭제 하는것이 자유로움
      - 해당 함수를 통해 생성된  **해당함수.prototype** 을 참조 가능
      *(Ex Person()를 통해 생성된 객체 Kim은 Person.prototype으로 참조)*
      엥 어떻게 ? **Prototype Link속성 때문에 !!!!!!!!!!!**

#### ProtoType Link

~~~ js
- prototype 속성은 함수만 가지고 있고 __proto__ 는 모든 객체가 빠짐 없이 가지고 있는 속성임
- __proto__는 객체가 생성 될 때 조상이였던 함수의 prototype object를 가리킴
- kim 객체는 eyes라는 속성을 직접 가지고 있지 않기 때문에 이것을 이용하여 eyes속성을 찾을 때 까지 항위프로토 타입을 검색
- 최상위인 object Prototype object 까지 도달했는데도 못 찾으면 undefined 리턴
~~~

##### 그냥 알아두기....

- 모든 객체는 Object의 자식이라고 불림
- 그렇기 때문에 Object Prototype object에 있는 모든 속성들을 사용 가능함
- ProtoType Chain : ProtoType Link 속성을 통해 상위 프로토 타입과 연결 되어 있는 형태


### 객체지향 프로그래밍(OOP,Object Oriented Programming)

~~객체기반과 객체지향의 차이를 알아보다가 확실하게 객체지향 패러다임을 정리하고 싶어서 함께 정리함~~

**OOP KEY WORD: 클래스+인스턴스(객체), 추상화,캡슐화,상속,다형성**
1. **객체지향프로그래밍 ?**
   - 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법     
   - 장점 : 코드 재사용성 증가, 유지보수 쉬움, 대형 프로젝트에 적합(클래스 단위로 모듈화 시켜 개발 할 수 있기 때문에)
   - 단점 : 처리 속도가 상대적으로 느림, 객체가 많아지면 용량이 커짐, 설계 복잡
2. **클래스 & 인스턴스 (객체)**
   - 클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행동(behavior)을 변수와 메소드로 정의 한 것
   - 인스턴스 : 클래스에서 정의한 것을 토대로 실제 메모리에 할 당 된 것 즉, 실제 프로그램에서 사용하는 데이터
3. **추상화**
    - 불필요한 정보는 숨기고 중요한 정보만을 표현함으로서 공통의 속성이나 기능을 묶어 이름을 붙이는 것 (=객체지향 관점에선 클래스를 정의하는 것임)
    - abstract class , abstract method 와는 전혀 관련 없음
4. **캡술화**
    - 기능과 특성의 모음을 클래스라는 캡슐에 분류해서 넣는것
    - 코드의 재활용성을 높이는 근본적 이유
    - 코드를 재수정 없이 재활용 하는 것이 목적임
5. **상속**
   - 부모 클래스의 속성과 기능을 그대로 이어받아 사용가능하게 하고 기능의 일부분을 변경해야 할 경우 상속 받은 자식 클래스에서 해당기능만 다시 재정의 하여 사용 할 수 있게 함
   - java 같은 경우는 다중 상속 불가능 (c++은 다중상속 가능함)
6. **다형성**
   - 하나의 변수명,함수명등이 상황에 따라 다른 의미로 해석 됨 = 오버라이딩,오버로딩 가능
   - 오버라이딩 : 부모클래스의 메소드와 같은 이름, 매개변수를 재정의 하는 것
   - 오버로딩 : 같은 이름의 함수를 여러개 정의하고 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출 할 수 있도록 하는 것
